import cv2, numpy as np, os

# === Đường dẫn ===
SCENE_PATH = r"C:\Users\Administrator\Desktop\Charging\Icon.jpg"      # ảnh lớn (dashboard) - màu
ICON_PATH  = r"C:\Users\Administrator\Desktop\Charging\icon_03.png"   # icon nhỏ (template)

# --- màu cần tìm: 'red','orange','yellow','green','cyan','blue','magenta','white','gray','black'
TARGET_COLOR = 'green'

# === Tham số ===
SCALES = np.linspace(0.6, 1.6, 21)
EDGE_SCENE = (60, 160)      # Canny scene
EDGE_ICON  = (40, 120)      # Canny icon
SCORE_THR  = 0.20
MAX_PEAKS_PER_SCALE = 5
NMS_IOU_THR = 0.4
FONT = cv2.FONT_HERSHEY_SIMPLEX

# ---- Helpers ----
def iou(boxA, boxB):
    (x1, y1, x2, y2) = boxA
    (x1b, y1b, x2b, y2b) = boxB
    xi1, yi1 = max(x1, x1b), max(y1, y1b)
    xi2, yi2 = min(x2, x2b), min(y2, y2b)
    inter = max(0, xi2 - xi1) * max(0, yi2 - yi1)
    areaA = max(0, x2 - x1) * max(0, y2 - y1)
    areaB = max(0, x2b - x1b) * max(0, y2b - y1b)
    union = areaA + areaB - inter + 1e-6
    return inter / union

def nms(boxes, scores, iou_thr=0.5):
    idxs = np.argsort(scores)[::-1]
    keep = []
    while len(idxs) > 0:
        i = idxs[0]
        keep.append(i)
        rest = []
        for j in idxs[1:]:
            if iou(boxes[i], boxes[j]) <= iou_thr:
                rest.append(j)
        idxs = np.array(rest, dtype=int) if rest else np.array([], dtype=int)
    return keep

def color_name_from_bgr(bgr):
    b, g, r = bgr
    hsv = cv2.cvtColor(np.uint8([[bgr]]), cv2.COLOR_BGR2HSV)[0,0]
    h, s, v = int(hsv[0]), int(hsv[1]), int(hsv[2])
    if v < 40:  return "black"
    if s < 35 and v > 200: return "white"
    if s < 35:  return "gray"
    if   h < 8 or h >= 170: return "red"
    elif h < 18: return "orange"
    elif h < 35: return "yellow"
    elif h < 85: return "green"
    elif h < 105: return "cyan"
    elif h < 135: return "blue"
    else: return "magenta"

def color_match_bgr(bgr, target:str) -> bool:
    """Match theo HSV mean + logic gần giống với color_name_from_bgr, nhưng bao phủ 2 nhánh đỏ."""
    b, g, r = bgr
    hsv = cv2.cvtColor(np.uint8([[bgr]]), cv2.COLOR_BGR2HSV)[0,0]
    h, s, v = int(hsv[0]), int(hsv[1]), int(hsv[2])

    # trước tiên xử lý đen/xám/trắng
    if target == 'black':  return v < 50
    if target == 'white':  return (s < 35 and v > 200)
    if target == 'gray':   return (s < 45 and 50 <= v <= 200)

    # màu bão hòa
    if s < 35:  # ít bão hòa → coi như không phải màu
        return False

    if target == 'red':
        return (h < 10) or (h >= 170)
    if target == 'orange':
        return 10 <= h < 20
    if target == 'yellow':
        return 20 <= h < 40
    if target == 'green':
        return 40 <= h < 85
    if target == 'cyan':
        return 85 <= h < 100
    if target == 'blue':
        return 100 <= h < 135
    if target == 'magenta':
        return 135 <= h < 170

    # nếu target không hợp lệ thì coi như match mọi màu
    return True

# --- 1) Load ảnh ---
scene_bgr = cv2.imread(SCENE_PATH)  # màu
if scene_bgr is None:
    raise FileNotFoundError(f"Không đọc được ảnh: {SCENE_PATH}")
scene = cv2.cvtColor(scene_bgr, cv2.COLOR_BGR2GRAY)

icon  = cv2.imread(ICON_PATH, cv2.IMREAD_GRAYSCALE)
if icon is None:
    raise FileNotFoundError(f"Không đọc được template: {ICON_PATH}")

# --- 2) Chuẩn hóa polarity: template trắng trên nền đen ---
if icon.mean() < 128:
    icon = cv2.bitwise_not(icon)

# --- 3) Edge map scene ---
scene_edges = cv2.Canny(cv2.GaussianBlur(scene, (3,3), 0), EDGE_SCENE[0], EDGE_SCENE[1])

H, W = scene.shape[:2]
candidates = []  # (score, (x1,y1,x2,y2), scale)

# --- 4) Multi-scale + lấy nhiều peak mỗi scale ---
for s in SCALES:
    icon_s = cv2.resize(icon, None, fx=s, fy=s, interpolation=cv2.INTER_AREA)
    h, w = icon_s.shape[:2]
    if h < 12 or w < 12 or h > H or w > W:
        continue

    icon_edges = cv2.Canny(cv2.GaussianBlur(icon_s, (3,3), 0), EDGE_ICON[0], EDGE_ICON[1])
    if cv2.countNonZero(icon_edges) < 20:
        continue

    res = cv2.matchTemplate(scene_edges, icon_edges, cv2.TM_CCOEFF_NORMED)

    res_work = res.copy()
    taken = 0
    while taken < MAX_PEAKS_PER_SCALE:
        _, max_val, _, max_loc = cv2.minMaxLoc(res_work)
        if max_val < SCORE_THR:
            break
        x, y = max_loc
        x1, y1, x2, y2 = x, y, x + w, y + h
        candidates.append((float(max_val), (x1, y1, x2, y2), float(s)))

        # suppress vùng quanh peak
        rx = max(1, w // 2); ry = max(1, h // 2)
        xL, xR = max(0, x - rx), min(res_work.shape[1], x + rx)
        yT, yB = max(0, y - ry), min(res_work.shape[0], y + ry)
        res_work[yT:yB, xL:xR] = -1.0
        taken += 1

# --- 5) NMS ---
if not candidates:
    print("❌ Không tìm thấy ứng viên nào.")
    out_path = os.path.join(os.path.dirname(SCENE_PATH), "airbag_match_out.jpg")
    cv2.imwrite(out_path, scene_bgr)
    print("Đã lưu:", out_path)
    raise SystemExit

boxes  = [c[1] for c in candidates]
scores = [c[0] for c in candidates]
scales = [c[2] for c in candidates]
keep_idx = nms(boxes, scores, iou_thr=NMS_IOU_THR)

# --- 6) Tính màu từng bbox, chọn bbox đúng màu theo score cao nhất ---
vis = scene_bgr.copy()
detections = []  # list of dict: {box, score, scale, mean_bgr, cname, color_match}
for i in keep_idx:
    score = scores[i]
    (x1,y1,x2,y2) = boxes[i]
    sc = scales[i]

    # ROI co 1px để tránh viền
    x1m, y1m = min(max(x1+1,0), x2-1), min(max(y1+1,0), y2-1)
    x2m, y2m = max(min(x2-1,W), x1m+1), max(min(y2-1,H), y1m+1)
    roi = vis[y1m:y2m, x1m:x2m]
    mean_bgr = tuple(int(v) for v in cv2.mean(roi)[:3]) if roi.size>0 else (0,0,0)
    cname = color_name_from_bgr(mean_bgr)
    cmatch = color_match_bgr(mean_bgr, TARGET_COLOR)
    detections.append({
        "box": (x1,y1,x2,y2),
        "score": score,
        "scale": sc,
        "mean_bgr": mean_bgr,
        "cname": cname,
        "match": cmatch
    })

# chọn ứng viên đúng màu có score cao nhất
color_matches = [d for d in detections if d["match"]]
if color_matches:
    chosen = max(color_matches, key=lambda d: d["score"])
    status_text = f"Found color={TARGET_COLOR}"
    status_ok = True
else:
    # fallback: không có đúng màu → chọn score cao nhất toàn bộ để quan sát
    chosen = max(detections, key=lambda d: d["score"])
    status_text = f"No {TARGET_COLOR} match; showing best"
    status_ok = False

# --- 7) Vẽ: khoanh tất cả, nhưng nổi bật bbox đã chọn ---
for d in detections:
    (x1,y1,x2,y2) = d["box"]
    color = (0,255,255) if d is chosen else (0,255,0)  # vàng cho bbox chọn, xanh cho còn lại
    cv2.rectangle(vis, (x1,y1), (x2,y2), color, 2 if d is chosen else 1)
    label = f"{d['score']:.3f}@{d['scale']:.2f} {d['cname']}"
    cv2.putText(vis, label, (x1, max(0,y1-6)), FONT, 0.5, color, 1, cv2.LINE_AA)

# ghi status
cv2.putText(vis, f"{status_text} | chosen: {chosen['cname']} score={chosen['score']:.3f}",
            (10, 20), FONT, 0.6, (0,255,0) if status_ok else (0,0,255), 2, cv2.LINE_AA)

# --- 8) Kết quả console ---
if status_ok:
    print(f"✅ Tìm thấy đúng màu '{TARGET_COLOR}'. Bbox={chosen['box']} score={chosen['score']:.3f} scale={chosen['scale']:.2f} meanBGR={chosen['mean_bgr']} ({chosen['cname']})")
else:
    print(f"⚠️ Không tìm thấy màu '{TARGET_COLOR}'. Hiển thị bbox tốt nhất Bbox={chosen['box']} score={chosen['score']:.3f} scale={chosen['scale']:.2f} meanBGR={chosen['mean_bgr']} ({chosen['cname']})")

# --- 9) Lưu ---
out_path = os.path.join(os.path.dirname(SCENE_PATH), "airbag_match_out.jpg")
cv2.imwrite(out_path, vis)
print("Đã lưu:", out_path)
